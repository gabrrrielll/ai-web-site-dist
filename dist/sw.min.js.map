{"version":3,"sources":["sw.js"],"names":["CACHE_NAME","self","event","caches","console","waitUntil","open","error","log","cache","addAll","urlsToCache","request","method","addEventListener","response","respondWith","fetch","match","then","networkResponse","url","startsWith","location","origin","status","put","clone","cacheWhitelist","cacheNames","indexOf","keys","all","map","skipWaiting","cacheName","data","type"],"mappings":"aAAA,IAAMA,WAAa,uBAAbA,YAAa,CAGjB,IADF,cAMAC,qBAEEC,KAAAA,iBACEC,UAAYH,SAAAA,GAERI,KAAAA,cACAF,EAAAG,UAHJF,OAAAG,KAKSN,YACLI,KAAQG,SAAAA,GAThB,OAEEH,QAAAI,IAAA,gBAFFC,EAAAC,OAAAC,eAGI,MAYF,SAAAJ,GACIL,QAAMU,MAAQC,6BAAkBN,QAMhCN,KAAAa,iBAAO,QAAkBF,SAAAA,GAET,QAAdV,EAAIa,QAAUF,QAJpBX,EAAMc,YASAb,OAAAG,KAAOW,YAAYL,KAAZ,SAAAH,GACL,OAAAA,EAAAS,MAAAhB,EAAAU,SAAAO,KAAA,SAAAJ,GAEE,OAAAA,GAKAE,MAAAf,EAAAU,SAAAO,KAAA,SAAAC,GAED,OAAAlB,EAAAU,QAAAS,IAAAC,WAAArB,KAAAsB,SAAAC,SAHGJ,GAA8C,MAA3BA,EAAgBK,QAPzChB,EAAAiB,IAAAxB,EAAAU,QAAAQ,EAAAO,SAoBFP,IAZM,MAKK,SAAAb,GAcjB,MALMH,QAAaF,MAAMU,gBAAnBL,GAKNA,QA3BQ,MA6BAqB,SAAAA,GAKE,OAJR1B,QAAMG,MACJF,0BAAmB0B,GAGTD,MAAAA,EAAeE,cAOvB1B,KAAAA,iBAAc,WAAA,SAAAF,GACf,IAZH0B,EAAA,CAAA5B,YAFFE,EAkBAG,UAfIF,OAAO4B,OAAOZ,KAAK,SAAAU,GAgBlBf,OAAAA,QAALkB,IACM9B,EAAA+B,IAAc/B,SAAAA,GACXgC,IAAL,IAAKA,EAALJ,QAAAK,GAFJ,OAGG/B,QAAAI,IAAA,sBAAA2B,GAHHhC,OAAA,OAAAgC,QAhBI,MASS,SAAA5B,GACPH,QAAQG,MAAM,wBAAyBA,QAM7CN,KAAKa,iBAAiB,UAAW,SAAAZ,GAC3BA,EAAMkC,MAA4B,iBAApBlC,EAAMkC,KAAKC,MAC3BpC,KAAKiC","file":"sw.min.js","sourcesContent":["const CACHE_NAME = 'ai-website-editor-v1';\n// This list should be expanded with actual bundled assets in a real build process.\nconst urlsToCache = [\n  '/',\n  '/index.html',\n  '/site-config.json'\n];\n\nself.addEventListener('install', event => {\n  self.skipWaiting(); // Activate worker immediately\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => {\n        console.log('Opened cache');\n        return cache.addAll(urlsToCache);\n      })\n      .catch(error => {\n        console.error('Cache installation failed:', error);\n      })\n  );\n});\n\nself.addEventListener('fetch', event => {\n  // We only want to cache GET requests.\n  if (event.request.method !== 'GET') {\n    return;\n  }\n\n  event.respondWith(\n    caches.open(CACHE_NAME).then(cache => {\n      return cache.match(event.request).then(response => {\n        // Return the cached response if it exists.\n        if (response) {\n          return response;\n        }\n\n        // If the request is not in the cache, fetch it from the network.\n        return fetch(event.request).then(networkResponse => {\n          // Don't cache third-party API requests (e.g., Gemini, Unsplash, Tailwind CDN)\n          if (!event.request.url.startsWith(self.location.origin)) {\n            return networkResponse;\n          }\n\n          // Also, don't cache responses that are not OK.\n          if (networkResponse && networkResponse.status === 200) {\n            // Clone the response because it's a one-time-use stream.\n            cache.put(event.request, networkResponse.clone());\n          }\n\n          return networkResponse;\n        }).catch(error => {\n          console.error('Fetch failed:', error);\n          // Return a fallback response or rethrow\n          throw error;\n        });\n      });\n    }).catch(error => {\n      console.error('Cache operation failed:', error);\n      // Fallback to network request\n      return fetch(event.request);\n    })\n  );\n});\n\n// Clean up old caches on activation\nself.addEventListener('activate', event => {\n  const cacheWhitelist = [CACHE_NAME];\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames.map(cacheName => {\n          if (cacheWhitelist.indexOf(cacheName) === -1) {\n            console.log('Deleting old cache:', cacheName);\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    }).catch(error => {\n      console.error('Cache cleanup failed:', error);\n    })\n  );\n});\n\n// Handle message events properly\nself.addEventListener('message', event => {\n  if (event.data && event.data.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n"]}